{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }

    "segment tree":{
        "prefix": "/segment-tree",
        "body": [
            "${1:int} tree[$2];",
            "",
            "void build(int l, int r, int pos){",
            "    if(l == r){",
            "        tree[pos] = ${3:0};",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    build(l, mid, 2*pos+1);",
            "    build(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1] + tree[2*pos+2];",
            "}",
            "",
            "int idx, val;",
            "void update(int l, int r, int pos){",
            "    if(l > idx || r < idx) return;",
            "    if(l == r){",
            "        tree[pos] = val;",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    update(l, mid, 2*pos+1);",
            "    update(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1] + tree[2*pos+2];",
            "}",
            "",
            "int ql, qr;",
            "${1:int} query(int l, int r, int pos){",
            "    if(l>qr) return 0;",
            "    if(r <= qr) return tree[pos];",
            "    int mid = (l+r)/2;",
            "    return query(l, mid, 2*pos+1) + query(mid+1, r, 2*pos+2);",
            "}",
		],
		"description": "A normal segtree template"
    },
    "segtree with range udpdate":{
        "prefix": "/segment-tree-lazy",
        "body":[
            "${1:int} tree[$2];",
            "${1:int} lazy[$2];",
            "",
            "void build(int l, int r, int pos){",
            "    lazy[pos] = 0;",
            "    if(l == r){",
            "        tree[pos] = ${3:0};",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    build(l, mid, 2*pos+1);",
            "    build(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1]+tree[2*pos+2];",
            "}",
            "",
            "void propagate_lazy(int l, int r, int pos){",
            "    tree[pos] += lazy[pos];",
            "    if(l!=r){",
            "        lazy[2*pos+1] += lazy[pos];",
            "        lazy[2*pos+2] += lazy[pos];",
            "    }",
            "    lazy[pos] = 0;",
            "}",
            "",
            "int ql, qr, val;",
            "void update(int l, int r, int pos){",
            "    if(lazy[pos]){",
            "        propagate_lazy(l, r, pos);",
            "    }",
            "    if(l > qr || r < ql) return;",
            "    if(l>=ql && r<=qr){",
            "        lazy[pos] += val;",
            "        propagate_lazy(l, r, pos);",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    update(l, mid, 2*pos+1);",
            "    update(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1]+tree[2*pos+2];",
            "}",
            "",
            "${1:int} query(int l, int r, int pos){",
            "    if(lazy[pos]){",
            "        propagate_lazy(l, r, pos);",
            "    }",
            "   if(r < ql || l > qr)",
            "       return 0;",
            "   if(l>=ql && r<=qr)",
            "       return tree[pos];",
            "   int mid = (l+r)/1;",
            "   return query(l, mid, 2*pos+1)+query(mid+1, r, 2*pos+2);",
            "}",
        ],
        "description": "A segment tree with range update"
    },
    "fenwick tree":{
        "prefix": "/fenwick-tree",
        "body":[
            "template<class T>",
            "struct FenwickTree{",
            "   T *tree;",
            "   int sz;",
            "   FenwickTree(int n){",
            "       tree = new T[n+2];",
            "       sz = n;",
            "       memset(tree, 0, (n+2)*sizeof(T));",
            "   }",
            "   FenwickTree(T* arr, int n){",
            "       tree = new T[n+2];",
            "       tree[0] = 0;",
            "       sz = n;",
            "       for(int i=1;i<=n;i++)",
            "           tree[i] = tree[i-1]+arr[i];",
            "       for(int i=n;i>1;i--)",
            "           tree[i] -= tree[i - lastbit(i)];",
            "   }",
            "   FenwickTree(vector<T> &arr){",
            "       int n = arr.size();",
            "       tree = new T[n+2];",
            "       tree[0] = 0;",
            "       sz = n;",
            "       for(int i=1;i<=n;i++)",
            "           tree[i] = tree[i-1]+arr[i-1];",
            "       for(int i=n;i>1;i--)",
            "           tree[i] -= tree[i - lastbit(i)];",
            "   }",
            "   ~FenwickTree(){ delete[] tree;}",
            "   void update(int idx, T delta){",
            "       for(;idx<=sz;idx += lastbit(idx))",
            "           tree[idx] += delta;",
            "   }",
            "   int lower_bound(T value){",
            "       T sum = 0;",
            "       int pos = 0;",
            "       int LOGN = ceil(log2(sz));",
            "       for(int i=1<<LOGN; i>0; i>>=1){",
            "           if(pos + i < sz && sum + bit[pos + i] < v){",
            "               sum += bit[pos + i];",
            "               pos += i;",
            "           }",
            "       }",
            "       return pos + 1;",
            "   }",
            "   T sum(int idx){",
            "       T res = 0;",
            "       for(;idx >0;idx-=lastbit(idx)){",
            "           res += tree[idx];",
            "       }",
            "       return res;",
            "   }",
            "   static inline int lastbit(int a){ return a&(-a); }",
            "};",
        ],
        "description": "A fenwick tree / BIT template",
    },
    "fast pow":{
        "prefix": "/fast-pow-mod",
        "body": [
            "${1:int} powmod(${2:int} base, ${3:int} exp, ${1:int} mod){",
            "    ${1:int} ans = 1;",
            "    for(${1:int} val=base%mod;exp;exp>>=1){",
            "        if(exp&1)",
            "            ans = ans*val%mod;",
            "        val = val*val%mod;",
            "    }",
            "    return ans;",
            "}",
        ],
        "description": "Do modular fast exponentiation",
    },
    "mapper value":{
        "prefix": "/mapper-value",
        "body": [
            "template<class T>",
            "struct mapper{",
            "   std::vector<T> m;",
            "   mapper(){}",
            "   mapper(const T *arr, int sz){mapping(arr, sz);}",
            "   mapper(const vector<T> &arr){mapping(arr);}",
            "   void mapping(const T *arr, int sz){",
            "       m.clear();",
            "       for(int i=0;i<sz;++i)",
            "           m.pb(arr[i]);",
            "       sort(m.begin(), m.end());",
            "       m.erase(unique(m.begin(), m.end()), m.end());",
            "   }",
            "   void mapping(const vector<T> &arr){",
            "       m.clear();",
            "       for(const T &x : arr)",
            "           m.pb(x);",
            "       sort(m.begin(), m.end());",
            "       m.erase(unique(m.begin(), m.end()), m.end());",
            "   }",
            "   int get(const T &val){ return lower_bound(m.begin(), m.end(), val) - m.begin();}",
            "   int operator[] (const T &val){ return get(val);}",
            "};",
        ],
        "description": "Mapping value to [0, size]"
    },
    "template":{
        "prefix": "/template",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "#define fi first",
            "#define se second",
            "#define mp make_pair",
            "#define pb push_back",
            "#define INF 2000000000000000000LL",
            "#define EPS 1e-9",
            "#define debug(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"",
            "#define debug2(a, b) cerr<<#a<<\"=\"<<(a)<<\" \";debug(b)",
            "#define debug3(a, b, c) cerr<<#a<<\"=\"<<(a)<<\" \";debug2(b, c)",
            "#define debug4(a, b, c, d) cerr<<#a<<\"=\"<<(a)<<\" \";debug3(b, c, d)",
            "#define debug5(a, b, c, d, e) cerr<<#a<<\"=\"<<(a)<<\" \";debug4(b, c, d, e)",
            "#define FastSlowInput ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "typedef complex<double> cd;",
            "typedef pair<int, int> pii;",
            "typedef pair<ll, ll> pll;",
            "",
            "template<class T>",
            "void printArray(const T * a, int n, ostream& out = cerr);",
            "template<class T>",
            "void printArray(const vector<T> &arr, ostream& out = cerr);",
            "",
            "const ll mod = 1e9+7;",
            "const double PI = acos(-1);",
            "",
            "int n,i,j,k,t;",
            "",
            "int main(){",
            "    scanf(\"%d\", &n);",
            "    $0",
            "    return 0;",
            "}",
            "",
            "/* Template Function */",
            "template<class T>",
            "void printArray(const T * a, int n, ostream& out){",
            "    for(int i=0;i<n;++i){",
            "        out<<a[i]<<\" \";",
            "    }",
            "    out<<endl;",
            "}",
            "",
            "template<class T>",
            "void printArray(const vector<T> &arr, ostream& out){",
            "    for(const T& x : arr){",
            "        out<<x<<\" \";",
            "    }",
            "    out<<endl;",
            "}",
        ],
        "description": "usual template"
    }
}