// My custom snippets for competitive programming
// Feel free to copy, modify, and use it.
{
    "segment tree":{
        "prefix": "/segment-tree",
        "body": [
            "${1:int} tree[$2];",
            "",
            "void build(int l, int r, int pos){",
            "    if(l == r){",
            "        tree[pos] = ${3:0};",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    build(l, mid, 2*pos+1);",
            "    build(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1] + tree[2*pos+2];",
            "}",
            "",
            "int idx, val;",
            "void update(int l, int r, int pos){",
            "    if(l > idx || r < idx) return;",
            "    if(l == r){",
            "        tree[pos] = val;",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    update(l, mid, 2*pos+1);",
            "    update(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1] + tree[2*pos+2];",
            "}",
            "",
            "int ql, qr;",
            "${1:int} query(int l, int r, int pos){",
            "    if(l>qr) return 0;",
            "    if(r <= qr) return tree[pos];",
            "    int mid = (l+r)/2;",
            "    return query(l, mid, 2*pos+1) + query(mid+1, r, 2*pos+2);",
            "}",
		],
		"description": "A normal segtree template"
    },
    "segtree with range udpdate":{
        "prefix": "/segment-tree-lazy",
        "body":[
            "${1:int} tree[$2];",
            "${1:int} lazy[$2];",
            "",
            "void build(int l, int r, int pos){",
            "    lazy[pos] = 0;",
            "    if(l == r){",
            "        tree[pos] = ${3:0};",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    build(l, mid, 2*pos+1);",
            "    build(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1]+tree[2*pos+2];",
            "}",
            "",
            "void propagate_lazy(int l, int r, int pos){",
            "    tree[pos] += lazy[pos];",
            "    if(l!=r){",
            "        lazy[2*pos+1] += lazy[pos];",
            "        lazy[2*pos+2] += lazy[pos];",
            "    }",
            "    lazy[pos] = 0;",
            "}",
            "",
            "int ql, qr, val;",
            "void update(int l, int r, int pos){",
            "    if(lazy[pos]){",
            "        propagate_lazy(l, r, pos);",
            "    }",
            "    if(l > qr || r < ql) return;",
            "    if(l>=ql && r<=qr){",
            "        lazy[pos] += val;",
            "        propagate_lazy(l, r, pos);",
            "        return;",
            "    }",
            "    int mid = (l+r)/2;",
            "    update(l, mid, 2*pos+1);",
            "    update(mid+1, r, 2*pos+2);",
            "    tree[pos] = tree[2*pos+1]+tree[2*pos+2];",
            "}",
            "",
            "${1:int} query(int l, int r, int pos){",
            "    if(lazy[pos]){",
            "        propagate_lazy(l, r, pos);",
            "    }",
            "   if(r < ql || l > qr)",
            "       return 0;",
            "   if(l>=ql && r<=qr)",
            "       return tree[pos];",
            "   int mid = (l+r)/1;",
            "   return query(l, mid, 2*pos+1)+query(mid+1, r, 2*pos+2);",
            "}"
        ],
        "description": "A segment tree with range update"
    }
}